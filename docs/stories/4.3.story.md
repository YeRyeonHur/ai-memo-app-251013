# Story 4.3: 노트 내용 기반 자동 태그 생성

## Status

Ready for Review

---

## Story

**As a** 사용자,  
**I want** 작성한 노트의 내용을 분석하여 관련 태그를 자동으로 생성받기를 원한다,  
**so that** 노트를 효율적으로 분류하고 검색할 수 있다.

---

## Acceptance Criteria

1. 데이터베이스 스키마에 `tags` 테이블이 추가되어야 한다
   - `id` (UUID, Primary Key)
   - `note_id` (UUID, Foreign Key to notes)
   - `user_id` (UUID, 사용자 ID)
   - `tag` (TEXT, 태그 이름)
   - `model` (TEXT, 사용된 AI 모델명)
   - `created_at` (TIMESTAMP)
   - 인덱스: note_id, user_id, tag
   - 외래 키: note_id → notes(id) ON DELETE CASCADE
   - UNIQUE 제약조건: (note_id, tag) - 동일 노트에 중복 태그 방지

2. 태그 생성 Server Action이 구현되어야 한다
   - `generateTags(noteId: string)` 함수
   - 노트 내용을 가져와 Gemini API로 태그 생성
   - 생성된 태그를 tags 테이블에 저장
   - 인증된 사용자만 호출 가능
   - 자신의 노트만 태그 생성 가능 (권한 검증)

3. 태그는 3-6개로 구성되어야 한다
   - 각 태그는 1-3 단어로 간결하게
   - 한국어로 자연스럽게 생성
   - 노트의 주제와 카테고리를 반영
   - 쉼표로 구분된 형태로 생성
   - 소문자로 정규화

4. 태그 생성 프롬프트가 최적화되어야 한다
   - 명확한 지시사항 (3-6개 태그)
   - 한국어 출력 명시
   - 주제/카테고리 키워드 추출 강조
   - 1-3 단어로 간결하게 요청

5. 태그 조회 함수가 구현되어야 한다
   - `getTags(noteId: string)` 함수
   - 특정 노트의 모든 태그 반환
   - 권한 검증 (자신의 노트만 조회)
   - 태그가 없으면 빈 배열 반환

6. 태그 업데이트 함수가 구현되어야 한다
   - `updateTags(noteId: string, tags: string[])` 함수
   - 기존 태그 삭제 후 새 태그 삽입
   - 트랜잭션으로 원자성 보장
   - 중복 태그 자동 제거

7. 에러 처리가 구현되어야 한다
   - 노트를 찾을 수 없는 경우
   - 권한이 없는 경우
   - AI API 호출 실패
   - 토큰 제한 초과 (8k 토큰)
   - 타임아웃 (10초)
   - 모든 에러는 사용자 친화적인 한국어 메시지

8. 성능 최적화가 적용되어야 한다
   - 긴 노트는 토큰 제한에 맞게 자동 잘림
   - 동일 노트에 대한 중복 요청 방지 (기존 태그가 있으면 재사용 여부 확인)
   - 배치 삽입으로 DB 쿼리 최적화

9. 단위 테스트가 작성되어야 한다
   - generateTags 함수 테스트
   - getTags 함수 테스트
   - updateTags 함수 테스트
   - 권한 검증 테스트
   - 에러 처리 테스트
   - Mocking을 사용한 독립적인 테스트

---

## Tasks / Subtasks

- [ ] Task 1: 데이터베이스 스키마 수정 (AC: 1)
  - [ ] `drizzle/schema.ts`에 `tags` 테이블 정의 추가
    - [ ] id: UUID, Primary Key
    - [ ] noteId: UUID, Foreign Key
    - [ ] userId: UUID, 사용자 ID
    - [ ] tag: TEXT, 태그 이름
    - [ ] model: TEXT, AI 모델명
    - [ ] createdAt: TIMESTAMP
  - [ ] 인덱스 추가
    - [ ] note_id 인덱스 (조회 최적화)
    - [ ] user_id 인덱스 (권한 검증)
    - [ ] tag 인덱스 (검색 최적화)
  - [ ] UNIQUE 제약조건 추가 (note_id, tag)
  - [ ] 외래 키 제약 조건 추가 (ON DELETE CASCADE)
  - [ ] TypeScript 타입 정의 추가
    - [ ] Tag 타입
    - [ ] NewTag 타입
  - [ ] 마이그레이션 파일 생성
    - [ ] `pnpm drizzle-kit generate`
    - [ ] `pnpm drizzle-kit migrate` (개발 DB에 적용)

- [ ] Task 2: 태그 생성 Server Action 구현 (AC: 2, 5, 6, 7, 8)
  - [ ] `app/notes/ai-actions.ts`에 태그 관련 함수 추가
  - [ ] `generateTags(noteId: string)` 함수 구현
    - [ ] 인증 사용자 확인 (Supabase Auth)
    - [ ] noteId 유효성 검증
    - [ ] 노트 조회 (권한 검증 포함)
    - [ ] 노트 내용 토큰 제한 체크 및 자동 잘림
    - [ ] 기존 태그 확인 (있으면 재사용 여부 확인)
    - [ ] Gemini API 호출 (태그 생성)
    - [ ] 태그 결과 파싱 및 검증
    - [ ] 쉼표로 구분된 문자열을 배열로 변환
    - [ ] 태그 정규화 (trim, lowercase)
    - [ ] 중복 제거
    - [ ] tags 테이블에 배치 저장
    - [ ] 캐시 무효화 (revalidatePath)
    - [ ] 성공 결과 반환
  - [ ] `getTags(noteId: string)` 함수 구현
    - [ ] 인증 사용자 확인
    - [ ] 권한 검증 (자신의 노트만)
    - [ ] 모든 태그 조회
    - [ ] 태그가 없으면 빈 배열 반환
  - [ ] `updateTags(noteId: string, tags: string[])` 함수 구현
    - [ ] 인증 사용자 확인
    - [ ] 권한 검증
    - [ ] 트랜잭션 시작
    - [ ] 기존 태그 삭제
    - [ ] 새 태그 배치 삽입
    - [ ] 트랜잭션 커밋
    - [ ] 캐시 무효화
  - [ ] TypeScript 인터페이스 정의
    - [ ] GenerateTagsResult
    - [ ] GetTagsResult
    - [ ] UpdateTagsResult
  - [ ] 에러 핸들링
    - [ ] try-catch 블록
    - [ ] Gemini API 에러 파싱
    - [ ] 사용자 친화적 메시지 반환

- [ ] Task 3: 태그 파싱 유틸리티 (AC: 3)
  - [ ] `lib/gemini/prompts.ts`의 createTagsPrompt 함수 검토 (4.2에서 이미 구현됨)
  - [ ] `lib/gemini/utils.ts`에 태그 파싱 함수 추가
    - [ ] `parseTagsFromText(text: string)` 함수
    - [ ] 쉼표로 구분된 문자열 파싱
    - [ ] 공백 제거 및 소문자 변환
    - [ ] 빈 태그 제거
    - [ ] 중복 태그 제거
    - [ ] 최대 6개 제한
  - [ ] 테스트 작성
    - [ ] 정상 파싱 테스트
    - [ ] 공백 처리 테스트
    - [ ] 중복 제거 테스트
    - [ ] 빈 문자열 처리 테스트

- [ ] Task 4: AI Actions 단위 테스트 (AC: 9)
  - [ ] `app/notes/__tests__/ai-actions.test.ts`에 태그 테스트 추가
  - [ ] generateTags 함수 테스트
    - [ ] 인증 사용자가 자신의 노트 태그 생성 성공
    - [ ] 비인증 사용자는 에러 반환
    - [ ] 존재하지 않는 노트는 에러 반환
    - [ ] 유효하지 않은 noteId 에러 처리
    - [ ] 태그 파싱 및 정규화 확인
    - [ ] 중복 태그 제거 확인
  - [ ] getTags 함수 테스트
    - [ ] 태그 조회 성공
    - [ ] 권한 검증
    - [ ] 태그가 없으면 빈 배열 반환
  - [ ] updateTags 함수 테스트
    - [ ] 태그 업데이트 성공
    - [ ] 기존 태그 삭제 확인
    - [ ] 새 태그 삽입 확인
  - [ ] Mocking 전략
    - [ ] Supabase Auth 모킹
    - [ ] Drizzle ORM 모킹
    - [ ] Gemini API 모킹
    - [ ] Next.js revalidatePath 모킹

- [ ] Task 5: 통합 및 문서화
  - [ ] 단위 테스트 실행 및 검증
  - [ ] 코드 주석 추가
    - [ ] 각 함수에 JSDoc 주석
    - [ ] 복잡한 로직 설명 (파싱, 정규화)
  - [ ] 사용 예시 작성 (함수 JSDoc에 포함)
    - [ ] generateTags 호출 방법
    - [ ] getTags 호출 방법
    - [ ] updateTags 호출 방법

---

## Dev Notes

### 기술 스택 및 아키텍처 정보

#### 데이터베이스 스키마

**tags 테이블 구조**:
```typescript
export const tags = pgTable(
  'tags',
  {
    id: uuid('id').defaultRandom().primaryKey(),
    noteId: uuid('note_id').notNull().references(() => notes.id, { onDelete: 'cascade' }),
    userId: uuid('user_id').notNull(),
    tag: text('tag').notNull(),
    model: text('model').notNull().default('gemini-2.0-flash'),
    createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
  },
  (table) => ({
    noteIdIdx: index('tags_note_id_idx').on(table.noteId),
    userIdIdx: index('tags_user_id_idx').on(table.userId),
    tagIdx: index('tags_tag_idx').on(table.tag),
    uniqueNoteTag: unique('tags_note_id_tag_unique').on(table.noteId, table.tag),
  })
);

export type Tag = typeof tags.$inferSelect;
export type NewTag = typeof tags.$inferInsert;
```

[Source: docs/architecture.md - 데이터 모델]

#### 태그 생성 프롬프트

**프롬프트 구조**:
```
당신은 노트 내용을 분석하여 관련 태그를 생성하는 AI 어시스턴트입니다.

다음 노트의 내용을 분석하여 최대 6개의 태그를 생성해주세요.

요구사항:
- 노트의 주제, 카테고리, 키워드를 반영한 태그
- 한국어로 작성
- 각 태그는 1-3 단어로 간결하게
- 최소 3개, 최대 6개의 태그
- 쉼표로 구분하여 나열
- 태그는 소문자로 작성

노트 내용:
{content}

태그 (쉼표로 구분):
```

[Source: lib/gemini/prompts.ts - createTagsPrompt, Story 4.2에서 이미 구현됨]

#### Server Actions 패턴

기존 패턴 참고 (Story 4.2):
```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { db } from '@/lib/db'

export async function generateTags(noteId: string) {
  try {
    // 1. 인증 확인
    // 2. 노트 조회 및 권한 검증
    // 3. 태그 생성 (Gemini API)
    // 4. 태그 파싱 및 정규화
    // 5. DB 저장
    // 6. 캐시 무효화
    
    return { success: true, tags: ['태그1', '태그2'] }
  } catch (error) {
    return { success: false, error: '태그 생성 실패' }
  }
}
```

[Source: app/notes/ai-actions.ts from Story 4.2]

#### 태그 파싱 로직

```typescript
function parseTagsFromText(text: string): string[] {
  return text
    .split(',')
    .map(tag => tag.trim().toLowerCase())
    .filter(tag => tag.length > 0)
    .filter((tag, index, self) => self.indexOf(tag) === index) // 중복 제거
    .slice(0, 6) // 최대 6개
}
```

#### 성능 최적화

1. **배치 삽입**
   - 여러 태그를 한 번의 쿼리로 삽입
   - `db.insert(tags).values([...])` 사용

2. **중복 방지**
   - DB 레벨: UNIQUE 제약조건 (note_id, tag)
   - 애플리케이션 레벨: 중복 제거 로직

3. **토큰 관리**
   - 노트 내용이 8k 토큰 초과 시 자동 잘림
   - `truncateToTokenLimit()` 함수 활용

[Source: docs/epics/epic-4-ai-summarization-tagging.md]

#### 보안 고려사항

1. **권한 검증**
   - 노트 소유자만 태그 생성/조회/수정 가능
   - `WHERE user_id = {currentUserId}` 조건 필수

2. **입력 검증**
   - noteId 유효성 검사
   - 태그 길이 제한 (1-50자)
   - XSS 방지 (태그 sanitization)

[Source: docs/architecture.md - 보안]

### 테스트 전략

#### 테스트 파일 구조
```
app/notes/__tests__/
  ai-actions.test.ts           # AI Server Actions 테스트 (요약 + 태그)

lib/gemini/__tests__/
  utils.test.ts                # 유틸리티 함수 테스트 (태그 파싱 포함)
```

#### 테스트 커버리지

1. **태그 생성**
   - 정상 시나리오
   - 권한 검증
   - 토큰 제한 처리
   - 태그 파싱 및 정규화
   - 중복 제거
   - 에러 처리

2. **태그 조회**
   - 정상 조회
   - 권한 검증
   - 태그 없음 처리

3. **태그 업데이트**
   - 정상 업데이트
   - 트랜잭션 테스트
   - 권한 검증

4. **태그 파싱**
   - 정상 파싱
   - 공백 처리
   - 중복 제거
   - 빈 문자열 처리

#### 테스트 실행
```bash
pnpm test app/notes/ai-actions  # AI Actions 테스트
pnpm test lib/gemini/utils      # 유틸리티 테스트
```

[Source: package.json scripts]

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-14 | 1.0 | 스토리 최초 작성 | SM (Bob) |

---

## Dev Agent Record

### Agent Model Used

_Not yet assigned_

### Debug Log References

None

### Completion Notes List

_Not yet implemented_

### File List

_Not yet implemented_

---

## QA Results

_Not yet implemented_

